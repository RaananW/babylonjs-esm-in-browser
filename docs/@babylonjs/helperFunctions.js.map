{"version":3,"file":"helperFunctions.js","sourceRoot":"","sources":["../../../../../lts/core/generated/Shaders/ShadersInclude/helperFunctions.ts"],"names":[],"mappings":"AAAA,eAAe;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,2BAA2B,CAAC;AAExD,MAAM,IAAI,GAAG,iBAAiB,CAAC;AAC/B,MAAM,MAAM,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmKd,CAAC;AACF,aAAa;AACb,WAAW,CAAC,oBAAoB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,gBAAgB;AAChB,MAAM,CAAC,MAAM,eAAe,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC","sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"helperFunctions\";\nconst shader = `const float PI=3.1415926535897932384626433832795;\rconst float HALF_MIN=5.96046448e-08; \rconst float LinearEncodePowerApprox=2.2;\rconst float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;\rconst vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);\rconst float Epsilon=0.0000001;\r#define saturate(x) clamp(x,0.0,1.0)\n#define absEps(x) abs(x)+Epsilon\n#define maxEps(x) max(x,Epsilon)\n#define saturateEps(x) clamp(x,Epsilon,1.0)\nmat3 transposeMat3(mat3 inMatrix) {\rvec3 i0=inMatrix[0];\rvec3 i1=inMatrix[1];\rvec3 i2=inMatrix[2];\rmat3 outMatrix=mat3(\rvec3(i0.x,i1.x,i2.x),\rvec3(i0.y,i1.y,i2.y),\rvec3(i0.z,i1.z,i2.z)\r);\rreturn outMatrix;\r}\rmat3 inverseMat3(mat3 inMatrix) {\rfloat a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];\rfloat a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];\rfloat a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];\rfloat b01=a22*a11-a12*a21;\rfloat b11=-a22*a10+a12*a20;\rfloat b21=a21*a10-a11*a20;\rfloat det=a00*b01+a01*b11+a02*b21;\rreturn mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),\rb11,(a22*a00-a02*a20),(-a12*a00+a02*a10),\rb21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;\r}\r#if USE_EXACT_SRGB_CONVERSIONS\nvec3 toLinearSpaceExact(vec3 color)\r{\rvec3 nearZeroSection=0.0773993808*color;\rvec3 remainingSection=pow(0.947867299*(color+vec3(0.055)),vec3(2.4));\r#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nreturn mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.04045)));\r#else\nreturn\rvec3(\rcolor.r<=0.04045 ? nearZeroSection.r : remainingSection.r,\rcolor.g<=0.04045 ? nearZeroSection.g : remainingSection.g,\rcolor.b<=0.04045 ? nearZeroSection.b : remainingSection.b);\r#endif\n}\rvec3 toGammaSpaceExact(vec3 color)\r{\rvec3 nearZeroSection=12.92*color;\rvec3 remainingSection=1.055*pow(color,vec3(0.41666))-vec3(0.055);\r#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nreturn mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.0031308)));\r#else\nreturn\rvec3(\rcolor.r<=0.0031308 ? nearZeroSection.r : remainingSection.r,\rcolor.g<=0.0031308 ? nearZeroSection.g : remainingSection.g,\rcolor.b<=0.0031308 ? nearZeroSection.b : remainingSection.b);\r#endif\n}\r#endif\nfloat toLinearSpace(float color)\r{\r#if USE_EXACT_SRGB_CONVERSIONS\nfloat nearZeroSection=0.0773993808*color;\rfloat remainingSection=pow(0.947867299*(color+0.055),2.4);\rreturn color<=0.04045 ? nearZeroSection : remainingSection;\r#else\nreturn pow(color,LinearEncodePowerApprox);\r#endif\n}\rvec3 toLinearSpace(vec3 color)\r{\r#if USE_EXACT_SRGB_CONVERSIONS\nreturn toLinearSpaceExact(color);\r#else\nreturn pow(color,vec3(LinearEncodePowerApprox));\r#endif\n}\rvec4 toLinearSpace(vec4 color)\r{\r#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4(toLinearSpaceExact(color.rgb),color.a);\r#else\nreturn vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);\r#endif\n}\rfloat toGammaSpace(float color)\r{\r#if USE_EXACT_SRGB_CONVERSIONS\nfloat nearZeroSection=12.92*color;\rfloat remainingSection=1.055*pow(color,0.41666)-0.055;\rreturn color<=0.0031308 ? nearZeroSection : remainingSection;\r#else\nreturn pow(color,GammaEncodePowerApprox);\r#endif\n}\rvec3 toGammaSpace(vec3 color)\r{\r#if USE_EXACT_SRGB_CONVERSIONS\nreturn toGammaSpaceExact(color);\r#else\nreturn pow(color,vec3(GammaEncodePowerApprox));\r#endif\n}\rvec4 toGammaSpace(vec4 color)\r{\r#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4(toGammaSpaceExact(color.rgb),color.a);\r#else\nreturn vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);\r#endif\n}\rfloat square(float value)\r{\rreturn value*value;\r}\rvec3 square(vec3 value)\r{\rreturn value*value;\r}\rfloat pow5(float value) {\rfloat sq=value*value;\rreturn sq*sq*value;\r}\rfloat getLuminance(vec3 color)\r{\rreturn clamp(dot(color,LuminanceEncodeApprox),0.,1.);\r}\rfloat getRand(vec2 seed) {\rreturn fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);\r}\rfloat dither(vec2 seed,float varianceAmount) {\rfloat rand=getRand(seed);\rfloat normVariance=varianceAmount/255.0;\rfloat dither=mix(-normVariance,normVariance,rand);\rreturn dither;\r}\rconst float rgbdMaxRange=255.0;\rvec4 toRGBD(vec3 color) {\rfloat maxRGB=maxEps(max(color.r,max(color.g,color.b)));\rfloat D =max(rgbdMaxRange/maxRGB,1.);\rD =clamp(floor(D)/255.0,0.,1.);\rvec3 rgb=color.rgb*D;\rrgb=toGammaSpace(rgb);\rreturn vec4(clamp(rgb,0.,1.),D); \r}\rvec3 fromRGBD(vec4 rgbd) {\rrgbd.rgb=toLinearSpace(rgbd.rgb);\rreturn rgbd.rgb/rgbd.a;\r}\rvec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {\rvec3 invOrigVec=vec3(1.0,1.0,1.0)/origVec;\rvec3 halfSize=cubeSize*0.5;\rvec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;\rvec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;\rvec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);\rfloat distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);\rvec3 intersectPositionWS=vertexPos+origVec*distance;\rreturn intersectPositionWS-cubePos;\r}\r`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const helperFunctions = { name, shader };\n"]}